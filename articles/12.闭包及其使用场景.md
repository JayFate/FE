### 闭包的概念

### 什么是闭包

`闭包意味着内部函数始终可以访问外部函数的变量和参数，即使外部函数已经返回。`
我们可以在 JavaScript 中创建嵌套函数。内部函数可以访问外部函数的变量和参数(但是，不能访问外部函数的参数对象arguments)。
看看下面这个例子:
```javascript
function OuterFunction() {
    var outerVariable = 1;
    function InnerFunction() {
        console.log(outerVariable);
    }
    InnerFunction();  // 1
}
复制代码
```
InnerFunction() 可以访问 outerVariable

- 闭包特性 1：
```javascript
function OuterFunction() {
   var outerVariable = 100;
   function InnerFunction() {
       alert(outerVariable);
   }
   return InnerFunction;
}
var innerFunc = OuterFunction();
innerFunc(); // 100
```
在上面的例子, 当调用 OuterFunction() 时，从 OuterFunction 返回InnerFunction 函数。变量 innerFunc 只引用InnerFunction()，而不是OuterFunction()。现在，当你调用 innerFunc() 时，它仍然可以访问在 OuterFunction() 中声明的 outerVariable。这就是闭包。

- 闭包特性 2
```javascript
function Counter() {
    var counter = 0;
    function IncreaseCounter() {
        return counter += 1;
    };
    return IncreaseCounter;
}
var counter = Counter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
console.log(counter()); // 4
```
闭包的一个重要特征是外部变量可以在多次调用之间保持其状态。请记住，内部函数不保留外部变量的单独副本，但它引用外部变量，这意味着如果您使用内部函数改变它，外部变量的值将被改变。
在上面的例子中，外部函数 Counter 返回内部函数 IncreaseCounter。增加 IncreaseCounter 将外部变量 counter 加1。因此多次调用 IncreaseCounter 函数将使 counter 多次加1。

- 闭包特性 3
```javascript
function Counter() {
    
    var counter = 0;
    setTimeout( function () {
        var innerCounter = 0;
        counter += 1;
        console.log("counter = " + counter);
        setTimeout( function () {
            counter += 1;
            innerCounter += 1;
            console.log("counter = ", counter)
            console.log("innerCounter = ", innerCounter)
        }, 500);
    }, 1000);
};
Counter();
```
闭包在多层内部函数中是有效的。


什么时候使用闭包

- 隐藏内部实现细节
```javascript
var counter = (function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  };   
})();
alert(counter.value()); // 0
counter.increment();
counter.increment();
alert(counter.value()); // 2
counter.decrement();
alert(counter.value()); // 1
```
在上面的示例中，increment()、decrement() 和 value()成为公共函数，因为它们包含在返回对象中，而changeBy() 函数成为私有函数，因为它没有返回，只被 increment() 和 decrement() 内部使用。

- 函数防抖
```javascript
window.onresize = function() {
  debounce(fn, 1000);
};
var fn = function() {
  console.log("fn");
};
function debounce(fn,time){
    let timer = null;
    return function(){
        if(timer){
            clearTimeout(timer)
        }
        timer = setTimeout(()=>{
            fn.apply(this,arguments)
        },time)
    }
}
```

### 具体使用场景

### 1.函数防抖 

比如要缩放窗口 触发onresize 事件 需要在这时候做一件事情,但是我们希望拖动的时候只触发一次,比如

```js
window.onresize = function(){
    console.log('onresize')//只想触发一次
}
```

一般方法vs闭包

```js
// 不使用闭包
window.onresize = function () {
  debounce(fn, 1000)
}
var fn = function () {
  console.log('fn')
}
var time = ''
function debounce(fn, timeLong) {
  if (time) {
    clearTimeout(time)
    time = ''
  }

  time = setTimeout(function () {
    fn()
  }, timeLong)
}



// 使用闭包
window.onresize = debounce(fn, 500)

function debounce(fn) {
  var timer = null
  return function () {
    if (timer) {     //timer第一次执行后会保存在内存里 永远都是执行器 直到最后被触发
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(function () {
      fn()
    }, 1000)
  }
}
var fn = function () {
  console.log('fn')
}
```

### 2.使用闭包设计单例模式

```js
class CreateUser {
  constructor(name) {
    this.name = name;
    this.getName();
  }
  getName() {
    return this.name;
  }
}
// 代理实现单例模式
var ProxyMode = (function () {
  var instance = null;
  return function (name) {
    if (!instance) {
      instance = new CreateUser(name);
    }
    return instance;
  }
})();
// 测试单体模式的实例
var a = ProxyMode("aaa");
var b = ProxyMode("bbb");
// 因为单体模式是只实例化一次，所以下面的实例是相等的
console.log(a === b);    //true
```

### 3.设置私有变量

内部属性 在java里使用private就可以,但是js 还没有这个东东

```js
let _width = Symbol();

class Private {
  constructor(s) {
    this[_width] = s
  }

  foo() {
    console.log(this[_width])
  }

}

var p = new Private("50");
p.foo();
console.log(p[_width]);//可以拿到


//使用闭包设置私有变量
let sque = (function () {
  let _width = Symbol();

  class Squery {
    constructor(s) {
      this[_width] = s
    }

    foo() {
      console.log(this[_width])
    }
  }
  return Squery
})();

let ss = new sque(20);
ss.foo();
console.log(ss[_width])  // Uncaught ReferenceError: _width is not defined
```

### 4.拿到正确的值（老掉牙的问题了😝）

```js
for (var i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log(i)//10个10
  }, 1000)
}
```

遇到这种问题 如何用解决呢

```js
for (var i = 0; i < 10; i++) {
  ((j) => {
    setTimeout(function () {
      console.log(j)//1-10
    }, 1000)
  })(i)

}
```

原理是 声明了10个自执行函数，保存当时的值到内部



